# Editable Extended Prompts Design

**Date:** 2026-02-03
**Status:** Approved

## Overview

Allow users to edit extended prompts after they are generated by the LLM. Currently, extended prompts are displayed in a disabled text area that users cannot modify. This feature will make extended prompts fully editable while protecting against accidental overwrites.

## Current Behavior

When users click "Extend Prompt":
1. The prompt is sent to an LLM via `utils/prompt_utils.py`
2. The extended version is stored in session state as `f"{TASK_KEY}_extended_prompt"`
3. It's displayed in a **disabled** text area (line 155-161 in t2v_a14b.py)
4. Users cannot modify it
5. The extended prompt is used for generation if available

## Proposed Changes

### 1. Make Extended Prompts Editable

**Change the text area widget:**
- Remove `disabled=True` flag
- Add `key` parameter to bind to session state for automatic syncing
- Update expander label from "Extended Prompt (from LLM)" to "Extended Prompt (editable)"

**Before:**
```python
if st.session_state.get(f"{TASK_KEY}_extended_prompt"):
    with st.expander("Extended Prompt (from LLM)", expanded=True):
        st.text_area(
            "Extended",
            value=st.session_state[f"{TASK_KEY}_extended_prompt"],
            height=150,
            disabled=True,
            label_visibility="collapsed",
        )
```

**After:**
```python
if st.session_state.get(f"{TASK_KEY}_extended_prompt"):
    with st.expander("Extended Prompt (editable)", expanded=True):
        st.text_area(
            "Extended",
            value=st.session_state[f"{TASK_KEY}_extended_prompt"],
            height=150,
            key=f"{TASK_KEY}_extended_prompt_edit",
            label_visibility="collapsed",
        )
```

### 2. Add Confirmation Before Re-Extension

**Prevent accidental overwrites with two-step confirmation:**

1. Add new session state variable: `f"{TASK_KEY}_confirm_extend"`
2. On first click when extended prompt exists: set confirmation flag and show warning
3. On second click: proceed with extension and reset confirmation flag
4. Always extend immediately if no existing extended prompt

**Implementation:**
```python
# Initialize confirmation state
if f"{TASK_KEY}_confirm_extend" not in st.session_state:
    st.session_state[f"{TASK_KEY}_confirm_extend"] = False

# Button logic with confirmation
col1, col2 = st.columns([1, 4])
with col1:
    has_existing = st.session_state.get(f"{TASK_KEY}_extended_prompt") is not None

    if has_existing and not st.session_state[f"{TASK_KEY}_confirm_extend"]:
        if st.button("Extend Prompt", disabled=not PROMPT_EXTEND_MODEL):
            st.session_state[f"{TASK_KEY}_confirm_extend"] = True
            st.rerun()
    else:
        button_label = "Confirm Extend" if st.session_state[f"{TASK_KEY}_confirm_extend"] else "Extend Prompt"
        extend_clicked = st.button(button_label, disabled=not PROMPT_EXTEND_MODEL)

# Show warning
if has_existing and st.session_state[f"{TASK_KEY}_confirm_extend"]:
    st.warning("⚠️ This will replace your current extended prompt. Click 'Confirm Extend' to proceed.")

# Handle extension
if extend_clicked:
    with st.spinner("Extending prompt..."):
        result = extend_prompt(prompt, TASK)
        if result.success:
            st.session_state[f"{TASK_KEY}_extended_prompt"] = result.extended_prompt
            st.session_state[f"{TASK_KEY}_confirm_extend"] = False  # Reset
            st.success("Prompt extended successfully!")
        else:
            st.warning(f"Extension failed: {result.message}")
```

### 3. Use Edited Prompt for Generation

**Update generation logic to prioritize edited version:**

```python
# Line ~191 in current implementation
generation_prompt = (
    st.session_state.get(f"{TASK_KEY}_extended_prompt_edit") or
    st.session_state.get(f"{TASK_KEY}_extended_prompt") or
    prompt
)
```

Priority order:
1. Edited extended prompt (if user modified it)
2. Original extended prompt (if not edited)
3. Original user prompt (if extension not used)

### 4. Update Metadata Tracking

**Save the edited prompt to metadata:**

In the metadata creation call, use the edited version:
```python
extended_prompt=st.session_state.get(f"{TASK_KEY}_extended_prompt_edit") or st.session_state.get(f"{TASK_KEY}_extended_prompt")
```

## Pages to Update

Apply changes consistently to all 6 pages:
- `pages/t2v_a14b.py` - Text-to-Video
- `pages/i2v_a14b.py` - Image-to-Video
- `pages/s2v_14b.py` - Speech-to-Video
- `pages/animate_14b.py` - Character animation
- `pages/ti2v_5b.py` - Text+Image-to-Video
- `pages/home.py` - (if it has extend prompt functionality)

Each page uses its own task-specific session state keys via `get_task_session_key(TASK)`, so changes are isolated per page.

## What's NOT Changing

- Backend prompt extension logic in `utils/prompt_utils.py`
- Original user prompt text area (remains unchanged)
- GPU settings, generation parameters
- Session state architecture

## Edge Cases

1. **Session state sync** - Streamlit's `key` parameter automatically syncs text area edits to session state
2. **Confirmation reset** - Reset `confirm_extend` flag after successful extension
3. **Empty edits** - If user deletes all text, fall back to original prompt
4. **Navigation** - Each page maintains its own extended prompt state, so switching pages doesn't affect stored prompts

## User Experience Flow

**First-time extension:**
1. User clicks "Extend Prompt"
2. LLM generates extended version
3. Extended prompt appears in editable text area
4. User can modify it freely

**Re-extension with existing prompt:**
1. User clicks "Extend Prompt"
2. Button changes to "Confirm Extend" + warning appears
3. User clicks "Confirm Extend" to proceed
4. New extended prompt replaces the old one
5. Button resets to "Extend Prompt"

**Generation:**
1. System uses edited extended prompt if available
2. Falls back to original extended prompt if not edited
3. Falls back to user's original prompt if extension not used

## Implementation Strategy

Update each page file identically:
1. Remove `disabled=True` from extended prompt text area
2. Add `key` parameter with task-specific key
3. Add confirmation state initialization
4. Update button logic with confirmation flow
5. Update generation prompt selection logic
6. Update metadata to use edited prompt

No shared utility extraction needed - the logic is simple and page-specific.
